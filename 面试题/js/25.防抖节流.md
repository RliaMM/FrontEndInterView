# 防抖节流

```javascript
let $eleThrottle = document.getElementById('throttle')
let $eleDebounce = document.getElementById('debounce')
const handlerBtn = function(event, type) {
  console.log(this, event, type)
}
window.onload = function() {
  //节流
  const btnThrottle = throttle(handlerBtn, 1000)
  $eleThrottle.addEventListener('click', function(event){
    btnThrottle(event, 1000)
  })
  // 防抖
  const btnDebounce = debounce(handlerBtn, 1000)
  $eleDebounce.addEventListener('click', function(event){
    btnDebounce(event)
  })
}

const throttle = function(func, delay){
  let timer = null
  return (...args) => {
    if (timer) { return }
    timer = setTimeout(() => {
      func.call(this, args, 'debounce')
      timer = null
    }, delay)
  }
}

const debounce = function(func, delay){
  let timer = null
  return (...args) => {
    clearTimeout(timer)
    timer = setTimeout(() => {
      func.call(this, args, 'debounce')
    }, delay)
  }
}
```

```js

const debounce = function(fn, delay, immediate){
  let timer = null
  return function() {
    timer && clearTimeout(timer)
    if (immediate) {
      !timer && fn.apply(this, arguments)
    }
    timer = setTimeout(() => {
      fn.apply(this, arguments)
    }, delay)
  }
}

const throttle = function(fn, delay){
  let timer = null
  return function() {
    if (timer) { return }
    timer = setTimeout(() => {
      fn.call(this, arguments, 'debounce')
      timer = null
    }, delay)
  }
}

```

## 防抖
- 在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。
## 节流
- 规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。

```js
function throttle (fn, wait, opts) {
  let args, context;
  let previous = 0;
  let timer = null;

  const laster = () => {

    // 第一次执行的话，previous 设置为0，再次开始执行，会走定时器触发执行
    previous = opts.leading === false ? 0 : Date.now(); 
    fn.apply(context, args);
  }
  const throttleFn = () => {
    args = arguments;
    context = this;
    const now = Date.now();

    // previous = 0 并且 第一次执行，则 previous = 当前时间，则走 定时器执行方法
    if(!previous && opts.leading === false) previous = now;
    
    const remain = wait - (now - previous);

    if (remain <= 0 ) {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      previous = now;
      fn.apply(context, arguments);
      
      //最后一次执行 并且 timer 为 null
    } else if(opts.trailing !== false && !timer){
      timer = setTimeout(laster, remain);
    }
  }
  return throttleFn;
}
const btn = document.getElementById('button')
btn.addEventListener('click', throttle(btnClick, 1000, { leading: false })); 
// leading false 第一次不执行， true 第一次执行
// trailing false 最后一次不执行，true最后一次执行
```