# JS 垃圾回收和 v8 的垃圾回收机制有什么区别

## 为什么又
程序的运行过程中，会使用内存。而内存空间是有限的，因此，内存空间的重复利用就变得非常重要。垃圾回收的概念也因此而生。
## 什么是垃圾回收

js 垃圾回收是自动的，非手动释放，也叫自动内存管理。
当环境中的变量，不再使用（没有被引用的关系），则在在下一波清理过程中被回收

### 常用的方式
引用计数法
缺点：无法解决循环引用问题

## V8

- 分为老生代，和新生代
  - 新生代：分为 from to, 互相交互切换，当一个变量被交换次数达到 5 次以上， 晋升成为老生带，新生代速度快，容量小
  - 老生带容量大，速度慢，一些资源比较大的，会直接放在老生带中
    - 老生代回收方式：
      - 标记清除：容易产生碎片
      - 标记整理：无碎片较慢
      - 增量标记：垃圾回收与应用程序交替使用

## 内存泄露

不在使用的变量，并没有得到及时释放

## 内存泄露方式

- 定时器未释放
```js
const intervalTime = setInterval(function () {
    console.log("------")
 }, 2000)
```
- 闭包为销毁
```js
// a 没释放
function fn1() {
  let a = 2
   function fn2() {
      console.log(++a)
     }
   return fn2
  }
  const fn = fn1()
  fn()

  fn = null // 等待回收
```
- 意外的全局变量
```js
// 意外全局变量（文件头部增加 'use strict'）
function fn1() {
  a = 1
  console.log(a)
}
fn1()
```
- dom 元素删除引用还存在
```js 
var elements = {
    button: document.getElementById('button'),
    image: document.getElementById('image'),
    text: document.getElementById('text')
};
function doStuff() {
    image.src = 'http://some.url/image';
    button.click();
    console.log(text.innerHTML);
}
function removeButton() {
  document.body.removeChild(document.getElementById('button'));
  // 但是还在elements对象里保存着#button的引用, DOM元素还在内存里面。
}
// elements.button = null
```

## 内存泄露方法排查
performance 中 Heap 对应的部分就可以看到内存在周期性的回落也可以看到垃圾回收的周期,如果垃圾回收之后的最低值(我们称为min),min在不断上涨,那么肯定是有较为严重的内存泄漏问题。


## 内存泄露防止方法
- 定时器销毁
- 全局变量文件头部增加 use strict
- 闭包试用完毕销毁
- dom 元素删除 暂存变量重置未 null
- EventBus 解绑
- ES6 weakMap weakSet
- 添加监听事件 addEventListener 销毁 removeEventListener