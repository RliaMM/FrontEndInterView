# 执行上下文

每个函数执行的时候都会产生执行上下文
执行上下文是一个对象，里面包含有变量对象(当前函数的变量 VO)，其中全局的 VO 又称 GO (全局的 GO 可以在任何地方访问),
【但是执行上下文的 VO 我们不能访问的，主要是为了保护变量不能随意修改】
当前执行上下文的 VO 又称为 AO

# 执行上下文栈——调用栈——执行栈 Call Stack

调用栈也称为执行栈，也就是执行上下文栈，在函数执行的时候生成(每次函数执行都会产生一个)
栈低是全局执行上下文，栈顶是当前函数执行上下文
栈是一种数据结构，里面放有很多执行上下文栈

# 作用域链 scopeChain

scope 是在函数创建的时候生成的，跟在哪里执行没有关系
执行上下文，内部不仅有 VO, this, 还有 scope
一个变量定义会现在本局域块内查找，找不到向父级作用域块查找，直到找到全局 gobal，未找到报错

## 阶段

执行上下文有两个阶段

- 编译阶段
  函数在创建阶段会被赋值，而变量是 undefined，遇到变量重名不会覆盖，let 不会放在 vo 里

- 执行阶段
  执行阶段给变量进行赋值

- 作用域链

```js
function two() {
  console.log(a);
}
function one() {
  var a = 2;
  two();
}
var a = 1;
one(); 

// -----
// 1
let globalEC = {
  vo: {
    one: () => {},
    rwo: () => {},
    a: 1,
  },
};
```

- 优先级 函数声明 > arguments > 函数声明

```js
function sum(a, b) {
  function a() {
    console.log(1);
  }
  var a = function () {
    console.log(2);
  };
  a();
}
sum(1, 2); 

// 打印2
```

```js
function sum(a, b) {
  var a = function () {
    console.log(2);
  };
  function a() {
    console.log(1);
  }
  a();
}
sum(1, 2); // 打印2
```

```js
function sum(a, b) {
  a();
  var a = function () {
    console.log(2);
  };
  function a() {
    console.log(1);
  }
}
sum(1, 2); // 打印1
```

```js
a();
function a() {
  console.log(1);
}
var a = function () {
  console.log(2);
};
a();

// 输出 1 2
```

# 暂时性死区

在代码块内，使用 let 和 const 命令声明变量之前，该变量都是不可用的，语法上被称为暂时性死区。

```js
let a = 1;
function test() {
  console.log(a);
  let a = 2;
}
```

# 严格模式 use strict

非严格模式下是 window global, 严格模式下 undefined

# 词法作用域

variableEnvironment
laxicalEnvironment

let 声明变量会放到 词法环境中，其中一个 {} 为一个块，遇到一个 {} 创建一个词法作用域
